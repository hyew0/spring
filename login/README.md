# 로그인 처리1 - 쿠키, 세션

#### 패키지 구조 설계
- package 구조
  - hello.login
    - domain
      - item
      - member
      - login
    - web
      - item
      - member
      - login
- 도메인이 가장 중요하다.
  - 도메인 = 화면, UI, 기술 인프라 등등의 영역은 제외한 시스템이 구현해야 하는 핵심 비즈니스 업무 영역을 말함
  - 향후 web을 다른 기술로 바꾸어도 도메인은 그대로 유지할 수 있어야 한다.
    - 이렇게 하려면 web은 domain을 알고있지만 domain은 web을 모르도록 설계해야 한다. 이것을 web은 domain을 의존하지만, domain은 web을 의존하지 않는다고 표현한다.

- 로그인
  - 로그인 컨트롤러는 로그인 서비스를 호출해서 로그인에 성공하면 홈 화면으로 이동하고, 
  - 로그인에 실패하면 bindingResult.reject() 를 사용해서 글로벌 오류( ObjectError )를 생성한다. 
  - 그리고 정보를 다시 입력하도록 로그인 폼을 뷰 템플릿으로 사용한다.

## 로그인 처리하기 - 쿠키 사용
- 쿠키를 사용해서 로그인, 로그아웃 기능을 구현해보자.

- 로그인 상태 유지하기
  - 쿼리 파라미터를 계속 유지하면서 보내는 것은 매우 어렵고 번거로운 작업이다. 쿠키를 사용해보자.

#### 쿠키
  - 서버에서 로그인에 성공하면 HTTP 응답에 쿠키를 담아서 브라우저에 전달하자. 
  - 그러면 브라우저는 앞으로 해당 쿠키를 지속해서 보내준다.
- 쿠키에는 영속 쿠키와 세션 쿠키가 있다.
  - 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지
  - 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시 까지만 유지
- 브라우저 종료 시 로그아웃이 되길 바라는 경우 세션 쿠키 사용

- 쿠키 생성 로직
  - ```java
      Cookie idCookie = new Cookie("memberId", String.valueOf(loginMember.getId()));
      response.addCookie(idCookie);
    ```
    - 로그인에 성공하면 쿠키를 생성하고 HttpServletResponse 에 담는다. 
      - 쿠키 이름은 memberId 이고, 값은 회원의 id 를 담아둔다. 
      - 웹 브라우저는 종료 전까지 회원의 id 를 서버에 계속 보내줄 것이다.

- @CookieValue 를 사용하면 편리하게 쿠키를 조회할 수 있다.
  - 로그인 하지 않은 사용자도 홈에 접근할 수 있기 때문에 required = false 를 사용한다.

- th:text="|로그인: ${member.name}|" : 로그인에 성공한 사용자 이름을 출력한다.

## 쿠키와 보안 문제
- 보안 문제
  - 쿠키 값은 임의로 변경할 수 있다.
    - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
    - 실제 웹브라우저 개발자 모드 ->  Application -> Cookie 변경으로 확인
      - Cookie: memberId=1 -> Cookie: memberId=2 (다른 사용자의 이름이 보임)
  - 쿠키에 보관된 정보는 훔쳐갈 수 있다.
    - 만약 쿠키에 개인정보나 신용카드 정보가 있다며?
    - 이 정보가 웹 브라우저에도 보관되고, 네트워크 요청마다 계속 클라이언트에서 서버로 전달된다.
    - 쿠키의 정보가 나의 로컬 pc에서 털릴 수 있고, 네트워크 전송 구간에서 털릴 수도 있다.
  - 해커가 쿠키를 한 번 훔쳐가면 평생 사용할 수 있다.
    - 해커가 쿠키를 훔쳐가서 그 쿠키로 악의적인 요청을 계속 시도할 수 있다.
- 대안
  - 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 
    - 그리고 서버에서 토큰을 관리한다.
  - 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능 해야 한다.
  - 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 해당 토큰의 만료시간을 짧게(예: 30분) 유지한다. 
    - 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.

## 로그인 처리하기 - 세션 동작 방식
- 쿠키에는 보안 문제가 존재.
  - 이 문제를 해결하려면 중요한 정보를 모두 서버에 저장해야 한다.
  - 그리고 클라이언트와 서버는 추정 불가능한 임의의 식별자 값으로 연결해야 한다.
  - 이렇게 서버에 중요한 정보를 보관하고 연결을 유지하는 방법을 "세션"이라고 한다.

- 세션 ID를 생성하는데, 추정 불가능해야 한다.
  - UUID는 추정 불가능
    - Cookie: mySessionId=zz0101xx-bab9-4b92-9b32-dadb280f4b61
- 생성된 세션 ID와 세션에 보관할 값( memberA )을 서버의 세션 저장소에 보관한다.

- 클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다.
  - 서버는 클라이언트에 mySessionId 라는 이름으로 세션ID 만 쿠키에 담아서 전달한다.
  - 클라이언트는 쿠키 저장소에 mySessionId 쿠키를 보관한다.
- 중요
  - 여기서 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것이다.
  - 오직 추정 불가능한 세션 ID만 쿠키를 통해 클라이언트에 전달한다.

#### 로그인 이후 접근
- 클라이언트는 요청시 항상 mySessionId 쿠키를 전달한다.
- 서버에서는 클라이언트가 전달한 mySessionId 쿠키 정보로 세션 저장소를 조회해서 로그인시 보관한 세션 정보를 사용한다

- 정리
  - 세션을 사용해서 서버에서 중요한 정보를 관리하게 되었다. 덕분에 다음과 같은 보안 문제들을 해결할 수 있다.
  - 쿠키 값을 변조 가능, -> 예상 불가능한 복잡한 세션Id를 사용한다.
  - 쿠키에 보관하는 정보는 클라이언트 해킹시 털릴 가능성이 있다. -> 세션Id가 털려도 여기에는 중요한 정보가 없다.
  - 쿠키 탈취 후 사용 -> 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 서버에서 세션의 만료시간을 짧게(예: 30분) 유지한다. 
    - 또는 해킹이 의심되는 경우 서버에서 해당 세션을 강제로 제거하면 된다.

### 세션 직접 만들기
- 세션 관리는 크게 3가지 기능을 제공하면 된다.
  - 세션 생성
    - sessionId 생성 (임의의 추정 불가능한 랜덤 값)
    - 세션 저장소에 sessionId와 보관할 값 저장
    - sessionId로 응답 쿠키를 생성해서 클라이언트에 전달
  - 세션 조회
    - 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 값 조회
  - 세션 만료
    - 클라이언트가 요청한 sessionId 쿠키의 값으로, 세션 저장소에 보관한 sessionId와 값 제거

- 정리
  - 사실 세션이라는 것이 뭔가 특별한 것이 아니라 단지 쿠키를 사용하는데, 서버에서 데이터를 유지하는 방법일 뿐이라는 것을 이해했을 것이다.
  - 그런데 프로젝트마다 이러한 세션 개념을 직접 개발하는 것은 상당히 불편할 것이다. 
    - 그래서 서블릿도 세션 개념을 지원한다.
  - 이제 직접 만드는 세션 말고, 서블릿이 공식 지원하는 세션을 알아보자. 
  - 서블릿이 공식 지원하는 세션은 우리가 직접 만든 세션과 동작 방식이 거의 같다. 
  - 추가로 세션을 일정시간 사용하지 않으면 해당 세션을 삭제하는 기능을 제공한다.